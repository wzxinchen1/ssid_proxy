#!/bin/sh

# SSID代理核心脚本
# 版本: 3.0
# 功能: 基于网络接口的代理管理

CONFIG="/etc/config/ssid-proxy"
ENABLED_FLAG="/etc/ssid-proxy/enabled"
LOG="/var/log/ssid-proxy.log"
CONNECTION_LOG="/var/log/ssid-proxy-connections.log"
REQUEST_LOG="/var/log/ssid-proxy-requests.log"
IPTABLES="/usr/sbin/iptables"
CONNTRACK="/usr/sbin/conntrack"
IP="/usr/sbin/ip"

rm -f /var/log/ssid-proxy.log 
rm -f /var/log/ssid-proxy-connections.log 
rm -f /var/log/ssid-proxy-requests.log 
# 从配置读取日志级别
LOG_LEVEL="info"
[ -f "$CONFIG" ] && {
    LOG_LEVEL=$(uci -q get ssid-proxy.@global[0].log_level) || LOG_LEVEL="info"
}

# 日志函数
log() {
    local level="$1"
    local message="$2"
    
    # 定义日志级别权重（使用 case 替代关联数组）
    local level_weight=0
    case "$level" in
        debug) level_weight=0 ;;
        info) level_weight=1 ;;
        warning) level_weight=2 ;;
        error) level_weight=3 ;;
        *) level_weight=1 ;;
    esac
    
    local config_weight=1
    case "$LOG_LEVEL" in
        debug) config_weight=0 ;;
        info) config_weight=1 ;;
        warning) config_weight=2 ;;
        error) config_weight=3 ;;
        *) config_weight=1 ;;
    esac
    
    # 如果配置的日志级别高于当前消息级别，则不记录
    [ "$config_weight" -gt "$level_weight" ] && return
    
    # 添加日志级别前缀
    local prefix
    case "$level" in
        debug) prefix="DEBUG" ;;
        info) prefix="INFO " ;;
        warning) prefix="WARN " ;;
        error) prefix="ERROR" ;;
        *) prefix="?????" ;;
    esac
    
    # 记录到日志文件
    echo "$(date '+%Y-%m-%d %H:%M:%S') - [$prefix] $message" >> "$LOG"
    
    # 同时记录到系统日志
    logger -t ssid-proxy "[$prefix] $message"
}

# 记录连接信息
log_connection() {
    local src_ip=$1
    local dst_ip=$2
    local dst_port=$3
    local protocol=$4
    local action=$5
    local interface=$6
    
    # 获取地理信息（如果可用）
    local geo_info=""
    if [ -x "/usr/bin/geoiplookup" ]; then
        geo_info=$(geoiplookup "$dst_ip" 2>/dev/null | awk -F': ' 'NR==1 {print $2}')
    fi
    
    # 记录连接
    local timestamp=$(date +%s)
    echo "$timestamp|$src_ip|$dst_ip|$dst_port|$protocol|$action|$interface|$geo_info" >> "$CONNECTION_LOG"
}

# 记录请求信息
log_request() {
    local src_ip=$1
    local dst=$2
    local port=$3
    local protocol=$4
    local status=$5
    local interface=$6
    
    # 解析域名（如果是IP则跳过）
    local domain=""
    if echo "$dst" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$'; then
        domain=$dst
    elif [ -x "/usr/bin/host" ]; then
        domain=$(host "$dst" 2>/dev/null | awk '/has address/ {print $4; exit}')
    fi
    
    # 记录请求
    echo "$(date '+%Y-%m-%d %H:%M:%S')|$src_ip|$dst|$port|$protocol|$status|$interface|$domain" >> "$REQUEST_LOG"
}

# 应用代理规则
apply_rules() {

    log "info" "读取配置$CONFIG"
    
    # 读取配置
    if [ -f "$CONFIG" ]; then
        # 获取所有配置项
        uci show ssid-proxy | grep "ssid-proxy.@config\[.\]=.*" | cut -d '=' -f 1 | while IFS= read -r key _; do
            log "info" "分析：$key"
            local enabled=$(uci -q get "$key.enabled")
            local interface=$(uci -q get "$key.interface")
            local mode=$(uci -q get "$key.mode")
            local proxy_server_id=$(uci -q get "$key.proxy_server_id")
            
            # 获取代理服务器配置
            local listen_port=$(uci -q get ssid-proxy.$proxy_server_id.listen_port)
            
            local chainName="SSID_PROXY_$interface"
            $IPTABLES -t nat -F $chainName 2>/dev/null
            $IPTABLES -t nat -D PREROUTING -j $chainName 2>/dev/null
            $IPTABLES -t nat -X $chainName 2>/dev/null
            

            if [ ! -f "$ENABLED_FLAG" ]; then
                log "debug" "全局开关关闭，禁用所有规则"
                continue
            fi

            # 检查是否启用
            if [ "$enabled" != "1" ]; then
                log "debug" "配置 $config 未启用($enabled)，跳过"
                continue
            fi
                        
            # 获取该接口的客户端IP
            local ip=$(ip -4 addr show dev "$interface" | awk '/inet / {print $2}')

            log "debug" "配置网段$ip"
                
            case $mode in
                "proxy")

                    # 创建新链
                    $IPTABLES -t nat -N $chainName
                    $IPTABLES -t nat -I PREROUTING -j $chainName
                    
                    # 添加默认直通规则
                    $IPTABLES -t nat -A $chainName -j RETURN
                    log "info" "执行 iptables 命令: $IPTABLES -t nat -I SSID_PROXY_$interface -s \"$ip\" -p tcp -j DNAT --to-destination 127.0.0.1:$listen_port -m comment --comment \"SSID代理:$interface\""
                    # 添加透明代理规则（排除局域网IP范围）
                    $IPTABLES -t nat -A SSID_PROXY_$interface -d 10.0.0.0/8 -j RETURN
                    $IPTABLES -t nat -A SSID_PROXY_$interface -d 169.254.0.0/16 -j RETURN
                    $IPTABLES -t nat -A SSID_PROXY_$interface -d 192.168.0.0/16 -j RETURN
                    $IPTABLES -t nat -I SSID_PROXY_$interface -s "$ip" -p tcp -j DNAT \
                            --to-destination 127.0.0.1:$listen_port \
                            -m comment --comment "SSID代理:$interface"
                    log "info" "为 $ip (接口: $interface) 应用代理规则到 127.0.0.1:$listen_port"
                    log_connection "$ip" "$proxy_ip" "$proxy_port" "TCP" "PROXY" "$interface"

                    ;;
                "block")
                    $IPTABLES -t nat -I SSID_PROXY -s "$ip" -j DROP \
                            -m comment --comment "INTERFACE-PROXY:$interface"
                    log "info" "已阻止 $ip (接口: $interface) 的网络访问"
                    log_connection "$ip" "0.0.0.0" "0" "ALL" "BLOCK" "$interface"
                    ;;
                "direct")
                    # 确保直连设备不被代理（优先级最高）
                    $IPTABLES -t nat -I SSID_PROXY -s "$ip" -j RETURN \
                            -m comment --comment "INTERFACE-PROXY:$interface"
                    log "info" "为 $ip (接口: $interface) 设置直连模式"
                    ;;
            esac
        done
    else
        log "error" "配置文件 $CONFIG 不存在"
    fi
}

# 监控活跃连接
monitor_connections() {
    # 如果未启用，直接返回
    if [ ! -f "$ENABLED_FLAG" ]; then
        return
    fi
    
    # 检查conntrack是否可用
    if [ ! -x "$CONNTRACK" ]; then
        log "warning" "conntrack 不可用，无法监控活跃连接"
        return
    fi
    
    # 获取所有标记为INTERFACE-PROXY的连接
    $CONNTRACK -L -p tcp --label "INTERFACE-PROXY:*" 2>/dev/null | while read -r line; do
        # 解析连接信息
        local src_ip=$(echo "$line" | grep -o 'src=[^ ]*' | cut -d= -f2)
        local dst_ip=$(echo "$line" | grep -o 'dst=[^ ]*' | cut -d= -f2)
        local dst_port=$(echo "$line" | grep -o 'dport=[^ ]*' | cut -d= -f2)
        local state=$(echo "$line" | grep -o 'state=[^ ]*' | cut -d= -f2)
        local label=$(echo "$line" | grep -o 'label=INTERFACE-PROXY:[^ ]*' | cut -d: -f2)
        local bytes=$(echo "$line" | grep -o 'bytes=[^ ]*' | cut -d= -f2)
        local age=$(echo "$line" | grep -o 'age=[^ ]*' | cut -d= -f2)
        
        # 获取接口名称
        local interface="unknown"
        if [ -n "$label" ]; then
            interface=$label
        else
            # 通过源IP确定接口
            interface=$($IP route get "$src_ip" 2>/dev/null | awk '/dev/ {print $3}')
        fi
        
        # 记录请求
        log_request "$src_ip" "$dst_ip" "$dst_port" "TCP" "$state" "$interface"
        
        # 记录连接状态
        log "debug" "活跃连接: $src_ip → $dst_ip:$dst_port (状态: $state, 接口: $interface, 流量: $bytes 字节)"
    done
}

# 清理旧日志
cleanup_logs() {
    # 保留最近7天的日志
    local max_days=7
    
    # 主日志清理
    if [ -f "$LOG" ]; then
        log "debug" "清理旧的主日志"
        awk -v max_days=$max_days 'BEGIN { cutoff = systime() - max_days*86400 } 
        $1 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
            log_date = $1 " " $2
            gsub(/[-:]/, " ", log_date)
            log_ts = mktime(log_date)
            if (log_ts > cutoff) print
        }' "$LOG" > "$LOG.tmp" && mv "$LOG.tmp" "$LOG"
    fi
    
    # 连接日志清理
    if [ -f "$CONNECTION_LOG" ]; then
        log "debug" "清理旧的连接日志"
        awk -v max_days=$max_days -F'|' 'BEGIN { cutoff = systime() - max_days*86400 } 
        $1 > cutoff { print }' "$CONNECTION_LOG" > "$CONNECTION_LOG.tmp" && \
        mv "$CONNECTION_LOG.tmp" "$CONNECTION_LOG"
    fi
    
    # 请求日志清理
    if [ -f "$REQUEST_LOG" ]; then
        log "debug" "清理旧的请求日志"
        awk -v max_days=$max_days -F'|' 'BEGIN { cutoff = systime() - max_days*86400 } 
        {
            # 解析日志时间
            split($1, dt, /[- :]/)
            log_ts = mktime(dt[1] " " dt[2] " " dt[3] " " dt[4] " " dt[5] " " dt[6])
            if (log_ts > cutoff) print
        }' "$REQUEST_LOG" > "$REQUEST_LOG.tmp" && \
        mv "$REQUEST_LOG.tmp" "$REQUEST_LOG"
    fi
}

# 主逻辑
log "info" "接口代理服务启动 (日志级别: $LOG_LEVEL)"
log "info" "PID: $$"

# 应用规则
apply_rules


# 清理旧日志（每天执行一次）
current_hour=$(date +%H)
if [ "$current_hour" = "03" ]; then
    cleanup_logs
fi